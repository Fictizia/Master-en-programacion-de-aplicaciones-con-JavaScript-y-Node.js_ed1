![shieldsIO](https://img.shields.io/github/issues/Fictizia/Master-en-programacion-de-aplicaciones-con-JavaScript-y-Node.js_ed1.svg)
![shieldsIO](https://img.shields.io/github/forks/Fictizia/Master-en-programacion-de-aplicaciones-con-JavaScript-y-Node.js_ed1.svg)
![shieldsIO](https://img.shields.io/github/stars/Fictizia/Master-en-programacion-de-aplicaciones-con-JavaScript-y-Node.js_ed1.svg)

![WideImg](http://fictizia.com/img/github/Fictizia-plan-estudios-github.jpg)

# Master en Programación de Aplicaciones con JavaScript y Node.js
### JS, Node.js, Frontend, Express, Patrones, IoT, HTML5_APIs, Asincronía, Websockets, ECMA6, ECMA7

## Clase 109

### Python: Operadores de pertenencia
Podemos comprobar si un elemento se encuentra o no en una colección como cadenas, listas y tuplas.

- **in**
```python
    builtins_list = dir(__builtins__)
    "AssertionError" in builtins_list   #true
    "Otra cosa...." in builtins_list    #false
```
- **not in**
```python
    builtins_list = dir(__builtins__)
    "AssertionError" not in builtins_list   #false
    "Otra cosa...." not in builtins_list    #true
```

### Python: Operadores de identidad
Verifica si ambos elementos se refieren al mismo objeto
- **is**
```python
a = 1
b = 1
print(a is b) #True
```
- **is not**
```python
a = 1
b = 100
print(a is not b) #True
```
- **is vs. =**
```python
a = [1, True, "Cadena"]
b = [1, True, "Cadena"]
print(a is b) #False
print(a == b) #True
```

### Python: Comparadores básicos

**Importante:** 
En Python la comparación entre elementos se hace con sus valor binario. Lo que elimina la necesidad que usar la igualación por valor y tipo ( === y !==)

```python
    mayor_que = 100 > 10
    menor_que = 10 < 100
    mayor_igual = 100 >= 10
    menor_igual = 10 <= 100
    igual = 10 == 10
    no_gual = 100 != 10
```

### Python: Comparadores complejos (Operadores lógicos)

- AND(&)
```python
    comparacion = True and True # True
    comparacion = True and False # False
    comparacion = False and False # False
    comparacion = False and True # False
    
    # Se puede utilizar & también
    comparacion = True & True # True
    comparacion = True & False # False
    comparacion = False & False # False
    comparacion = False & True # False
    
    # Fuera de un contexto boleano devuelve otros resultados
    tres = 3
    dos = 2
    conjunto = tres and dos
```
- OR(|)
```python
    comparacion = True or True # True
    comparacion = True or False # True
    comparacion = False or False # False
    comparacion = False or True # True
    
    # Se puede utilizar | también
    comparacion = True | True # True
    comparacion = True | False # True
    comparacion = False | False # False
    comparacion = False | True # True
```

- not
```python
    comparacion = True and not(False) # True
```

- Ejemplos
```python
    ex_1 = True & True #True
    ex_2 = (2 == 2) & (3 >= 6) #False
    ex_3 = (2>3) | (17 <= 40) #True
    ex_4 = False | False #False
```


### Python: Asignación por igualdad
```python
    administrador = 'Yo mismo'
    esAdministrador = (administrador == 'Yo mismo')
    print(esAdministrador)
```
    
### Python: If...
- **If solamente**
```python
    variable = 100
    if ( variable  == 100 ): 
        print("Valor 100")
```

- **If... en línea**
```python
    variable = 100
    if ( variable  == 100 ) : print("Valor 100")
```

- **Else**
```python
    condicion = True;
    if condicion:
        print("True, por eso me ejecuto")
    else:
        print("False, por eso me ejecuto")
```


### Python: elif...
```python
condicion = 100
if condicion == 100:
   print("If....", condicion)
elif condicion == 200:
   print("Elif....", condicion)
else:
   print("Else...", condicion)
```


### Python: Switch

![fun](https://pydanny.com/static/aliens.png)

No existe en Python
- [Switch alternativo](http://www.pydanny.com/why-doesnt-python-have-switch-case.html)


### Python: Simplificado
- Clásico
```python
    condition = True
    if condition:
        print('yes')
    else:
        print('nah')
```

- Alternativo (Operador Ternario)
```python
    condition = True
    print('yes') if condition else print('nah')
    # expresion_1 if condicion_true else expresion_2
```

- Encapsulamiento, como parte de una asignación
```python
    invitado = True
    comensales = 1 + 1 if invitado else 0 # ERROR! -> (2 o 0)
    comensales = 1 + (1 if invitado else 0) # CORRECTO! -> (2 o 1)
```


### Python: While
- Bucle infinito: Este es un error muy común.
```python
while True:
    print("Este texto se imprime hasta el infinito...")
```
- Bucle que no se ejecutará:
```python
while False:
    print("Este texto jamas se imprimirá...")
```
- Ejemplo
```python
count = 0
while (count <= 10):
    print('Vuelta:', count)
    count += 1

print('Fin del bucle!')
```


### Python: For... in
Específico para listas o cadenas de texto.

- **Estructura**
```python
for iterating_var in sequence:
   statements(s)
```

- **String**
```python
for letra in 'Fictizia':
   print('Letra actual :', letra)
```

- **Listas** 
```python
lista = ['pan', 'huevos', 100, 1234]
for elemento in lista:
   print('Elemento actual :', elemento)
```

- **Tuplas** 
```python
tupla = ('pan', 'huevos', 100, 1234)
for elemento in tupla:
   print('Elemento actual :', elemento)
```

- **Anidación**
    - Funciona en todos los casos
    ```python
    list_of_lists = [ [1, 2, 3], [4, 5, 6], [7, 8, 9]]
    for list in list_of_lists:
        for x in list:
            print(x) 
    ```
    - Funciona en aquellos casos donde las longitudes sean comunes (No recomendado)
    ```python
    super_lista = [(1, 2), (3, 4)]
    for i,j in super_lista:
        print("i:"+str(i)+", j:"+str(j)) 
    ```

- **Usando range()**
    - Permite controlar un bucle con una progresión aritmetica
    - *Start* y *Step* son opcionales
    - *Stop* determina el tope del rango, el último valor incluido es Parar-1
    - Al incluir *Step*... también debemos incluir *Start*, pero no al revés
    - Estructura: `range([Start = 0], Stop, [Step = 1])`
    - Ejemplos:
        - Definiendo solo el máximo
        ```python
        for i in range(3):
            print("Vuelta número: %d" % (i))
        ```
        - Definiendo el mínimo
        ```python
        for i in range(3, 10):
            print("Vuelta número: %d" % (i))
        ```
        - Alterando el paso
        ```python
        for i in range(3, 10, 2):
            print("Vuelta número: %d" % (i))
        ```

### Python: Do... While
No existe en Python

- Alternativa
```python
while True:
  # Código.... 
  if False:
    break
```
- Ejemplo
```python
i = 0
while True:
    i += 1;
    print("Vuelta: ", i)
    if i < 10:
        break
```

- Alternativas:
	- [Emular Do... While en Python](http://stackoverflow.com/questions/743164/emulate-a-do-while-loop-in-python) 


### Python: Break y Continue
- **Continue** 
    - nos permite saltar parte del bucle.
    ```python
    for i in range (2):
        print("[Vuelta %d] esto va antes del continue!" % (i))
        continue
        print("esto va después del continue!")
    ```
    ```python
    count = 0
    while (count <= 10):
        count += 1
        if count == 5:
            continue
        print('Vuelta:', count)
    ```
- **Break**
    - nos permite salir del bucle.
    ```python
    count = 0
    while (count <= 10):
        count += 1
        if count == 5:
            break
        print('Vuelta:', count)
    ```

### Python: Usos Avanzados

**Else**
- Funciona con *for* y con *while*
- Se ejecutará cuando la condicción del bucle ya no sea *True*
- Existen excepciones como *ValueError*, *break*, *return* que evitaran que se ejecute el *else*
```python
count = 0
while (count <= 10):
    print('Vuelta:', count)
    count += 1
else:
    print('Fin del bucle!')
```


### Python: Números

**Tipos**
- Enteros
```python
type(23) #int - Base 10
type(0o27) #int - Octal
type(0x17 ) #int - Hexadecimal 
```
- Punto flotante
```python
type(0.2703) #float
type(0.1e-3) #float
```
- Complejos
```python
type(2.1 + 7.8j) #complex
```

**Conversión de Enteros**
```python
numero = 1626519864
numero_binario = bin(numero)
numero_hexadecimal = hex(numero)
numero_entero = int(1626519864.165)
numero_octal = oct(numero)
```

### Python: Módulo Math
- Es un módulo ideado para realizar operaciones matemáticas y científicas

**Importando**
```python
import math
print(math.pi)
```

**Números-teóricos y funciones representativas**
- `math.ceil(x)` *Retorna el techo*
- `math.copysign(x, y)` *Retorna un número flotante con el valor absoluto de x, pero el signo de y*
- `math.fabs(x)` *Retorna el valor absoluto*
- `math.factorial(x)` *Retorna el factorial o un error si no es entero o negativo*
- `math.floor(x)` *Retorna el máximo entero menor o igual a un número*
- `math.fmod(x, y)` *Retorna `fmod(x, y)` como se define en la librería de C*
- `math.frexp(x)` *Retorna la mantisa y exponente como el par `(m , e)`*
- `math.fsum(iterable)` *Retorna la suma (punto flotante) precisa de los valores en la lista/tupla...*
- `math.gcd(a, b)` *Retorna el máximo común divisor*
- `math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0)` *Verifica la cercanía entre dos números*
- `math.isfinite(x)` *(Desde v3.2) Verifica si no es ni infinito ni un NaN. 0.0 se considera infinito*
- `math.isinf(x)` *Verifica si es un núnmero infinito*
- `math.isnan(x)` *Verifica si es NaN*
- `math.ldexp(x, i)` *Retorna `x * (2**i)`*
- `math.modf(x)` *Retorna las partes fraccionarias y enteros*
- `math.trunc(x)` *Retorna el valor real truncado a una integral (número entero casi siempre)*

**Potencias y funciones logarítmicas**
- `math.exp(x)` *Retorna `e**x`*
- `math.expm1(x)` *Retorna `e**x - 1`*
- `math.log(x[, base])` *Retorna el logaritmo natural o con la base especificada `log(x)/log(base)`*
- `math.log1p(x)` *Retorna el logaritmo natural de 1+x (base e)*
- `math.log2(x)` *Retorna el logaritmo de base-2*
- `math.log10(x)` *Retorna el logaritmo de base-10*
- `math.pow(x, y)` *Retorna x elevado a la potencia de y*
- `math.sqrt(x)` *Retorna la raiz cuadrada*

**Funciones trigonométricas**
- `math.acos(x)` *Retorna arco coseno en radianes*
- `math.asin(x)` *Retorna arco seno en radianes*
- `math.atan(x)` *Retorna la tangente en radianes*
- `math.atan2(y, x)` *Retorna `atan(y / x)`, en radianes*
- `math.cos(x)` *Retorna el coseno*
- `math.hypot(x, y)` *Retorna la [norma euclidiana](https://www.wikiwand.com/es/Norma_vectorial)*
- `math.sin(x)` *Retorna el seno*
- `math.tan(x)` *Retorna la tangente*


**Conversión Angular**
- `math.degrees(x)` *Convierte de radianes a grados*
- `math.radians(x)` *Convierte de grados a radianes*

**Funciones hiperbólicas**
- `math.acosh(x)` *Retorna el coseno hiperbólico inverso*
- `math.asinh(x)` *Retorna el seno hiperbólico inverso*
- `math.atanh(x)` *Retorna la tangente hiperbólica inversa*
- `math.cosh(x)` *Retorna el coseno hiperbólico*
- `math.sinh(x)` *Retorna el seno hiperbólico*
- `math.tanh(x)` *Retorna la tangente hiperbólica*
 

**Funciones Especiales**
- `math.erf(x)` *(Desde v3.2) Retorna la [función error de Gauss](https://www.wikiwand.com/es/Funci%C3%B3n_error)*

![funcion](https://wikimedia.org/api/rest_v1/media/math/render/svg/8e659db8ac65279291e40733a160d895de0a9d98)
    
Se puede utilizar para funciones estadísticas
```python
def phi(x):
    'Cumulative distribution function for the standard normal distribution'
    return (1.0 + erf(x / sqrt(2.0))) / 2.0
```

- `math.erfc(x)` *(Desde v3.2) Retorna la [función error complementaria](https://www.wikiwand.com/es/Funci%C3%B3n_error)*

![funcion](https://wikimedia.org/api/rest_v1/media/math/render/svg/6e747e89de81a43b059918bfc5cdf9c892d1c86c)

- `math.gamma(x)` *(Desde v3.2) Retorna la [función Gamma](https://www.wikiwand.com/es/Funci%C3%B3n_gamma)*

![funcion](https://wikimedia.org/api/rest_v1/media/math/render/svg/2e33f1b6a1c65ad229ffec6865892bfa178dbad9)

- `math.lgamma(x)` *(Desde v3.2) Retorna el logaritmo natural del valor absoluto de la función gamma para x*


**Constantes**
- `math.pi` *π = 3.141592653589793*
- `math.e` *e = 2.718281828459045*
- `math.inf` *(Desde v3.5) Flotante. infinito negativo*
- `-math.inf` *(Desde v3.5) Flotante. infinito negativo*
- `math.nan` *(Desde v3.5) Flotante. Not A Number*


### Python: Módulo Cmath
- Es muy similar al *módulo math*, pero pensado para números complejos 
- [Documentación completa](https://docs.python.org/3/library/cmath.html)


### Python: Módulo Statistics
- Modulo pensado para la gestion y calculo estadistico
    - Promedios y medidas de tendencia central
    - Medidas de difusión
    - Otras funciones...
- [Documentación completa](https://docs.python.org/3/library/statistics.html)


### Python: Módulo Fractions
- Módulo ideado para la gestión de Números racionales (fracciones)
- [Documentación completa](https://docs.python.org/3/library/fractions.html)


### Python: Modulo Random
- Es un módulo especializado para lidiar con el azar.

**Importar el módulo**
```python
import random
```

**Métodos útiles**

- .randrange ([empieza=0,] termina [,paso=1]) *Retorna un numero al azar entre un rango determinado por nosotros*
```python
import random
print ("Entre 0-99:", random.randrange(100)) # 43
print ("Entre 10-40 (Pares):", random.randrange(10, 40, 2)) # 22
print ("Entre 11-33 (Impares):", random.randrange(11, 33, 2)) # 25
```

- .choice(lista) *Retorna un elemento al azar de una lista/tupla/cadena...*
```python
import random
fruta = random.choice(["Plátano", "Manzana", "Pera", "Kiwi"])
print(fruta)                        # Plátano
print(random.choice("Fictizia"))    # c
```

- .random() *Retorna un decimal aleatorio entre 0.0 y 1.0*
```python
import random
print("El azar dice", random.random()) # El azar dice 0.7689059637144342
```

- .shuffle(lista) *Reordena al azar los elementos de una lista*
```python
import random
lista = [2, 1, 16, 12, 45, 23,];
random.shuffle(lista)
print ("lista Reordenada:",  lista) # lista Reordenada: [23, 1, 2, 12, 16, 45]
```


- .uniform(minimo, maximo) *Retorna un decimal aleatorio entre el mínimo y máximo definido por nosotros*
```python
import random
print("El azar dice", random.uniform(5, 7)) # El azar dice 6.638733973842519
```

- .randint(minimo, maximo) *Retorna un entero aleatorio entre el mínimo y máximo definido por nosotros*
```python
import random
print("Tirada de dado (6 caras): ", random.randint(1, 6)) #3
print("Tirada de dado (20 caras): ", random.randint(1, 20)) #13
```


### Python: Módulo Decimal
- Creando decimales inmutables, con precisión
- Creando decimales
- Módulo muy extenso en métodos.
    - [Documentación completa](https://docs.python.org/3/library/decimal.html) 
```python
import decimal
decimal_1 = decimal.Decimal(32)
decimal_2 = decimal.Decimal(12.1238615234715283987639162398126374517235412034230486)
print(decimal_1 + decimal_2) # 44.12386152347152901143090276
```
- Comparando con Float
```python
import decimal
print("Version Float: ", 23 / 1.03) #22.33009708737864
print("Versión Decimal: ", decimal.Decimal(23) / decimal.Decimal(1.03)) #22.33009708737864019903562108
```


### Python: Python aplicado a la Ciencia

**Más información**
- [Python + Ciencia = \o/ (PyConES 2013)](https://www.youtube.com/watch?v=FnU0EYi63fI))
- [Presentando Sage, software matemático basado en Python (PyConES 2013)](https://www.youtube.com/watch?v=pNQPyolDyL4)
- [Learn Python for Science - NumPy, SciPy and Matplotlib de Shane Neeley](https://www.youtube.com/watch?v=oYTs9HwFGbY)
- [Introducción a Python para científicos e ingenieros](https://www.youtube.com/watch?v=1wKfeTqN8qQ)

**Módulos de la comunidad**
- [numpy](http://www.numpy.org/)
- [scipy](https://www.scipy.org/)
- [matplotlib](http://matplotlib.org/)



### Python: Módulo Time

**Importar el módulo**
```python
import time
```

**Métodos útiles**

- .time([hour[, minute[, second[, microsecond[, tzinfo]]]]]) *Creamos una fecha especifica o la actual*
```python
import time
print("Hora actual desde 01/01/70 a las 00:00 - ", time.time()) # 1470359626.8825448
```

- .localtime([segundos]) *Retorna una TimeTuple*

Posición     | Campo         | Valores
------------ | ------------- | -------------
0 | Año | 2016
1 | Mes | 1 - 12
2 | Día | 1 - 31
3 | Hora | 0 - 23
4 | Minuto | 0 - 59
5 | Segundo | 0 - 61 (61 bisiestos)
6 | Día de la semana | 0 - 6 (0 es Lunes)
7 | Día del año | 1 - 366
8 | Horario de verano | -1, 0, 1, -1 DST

```python
import time
print("Tiempo Local - ", time.localtime()) 
# time.struct_time(tm_year=2016, tm_mon=8, tm_mday=5, tm_hour=1, tm_min=15, tm_sec=27, tm_wday=4, tm_yday=218, tm_isdst=0)
```

- .asctime() *Formateando el tiempo*
```python
import time
print("asctime:", time.asctime( time.localtime(time.time()))) 
# asctime:  Fri Aug  5 01:25:46 2016
```

- .altzone() *Offset local en segudnos*
```python
import time
print("altzone:", time.altzone) # 0
```

- .clock() *benchmarking - Tiempo de procesamiento*
```python
import time

def procedure():
    time.sleep(5)

t0 = time.clock()
procedure()
print (time.clock() - t0, "- benchmark") # 0.0010940000000000116
```

- .ctime([segundos]) *Convierte el tiempo en una cadena representable*
```python
import time
print("ctime:", time.ctime()) # ctime: Fri Aug  5 01:41:53 2016
```

- .gmtime([segundos]) *Convierte el tiempo en una DateTuple UTC*
```python
import time
print ("gmtime :", time.gmtime(1470359626.8825448))
# gmtime : time.struct_time(tm_year=2016, tm_mon=8, tm_mday=5, tm_hour=1, tm_min=13, tm_sec=46, tm_wday=4, tm_yday=218, tm_isdst=0)
```

- .sleep(segundos) *Suspende la ejecucción por un número deteminado de segundos *
```python
import time
print("Empezamos el suspenso...")
time.sleep(5)
print("Termino el suspenso...")
```

- .strftime(formato [, segundos]) *Nos permite customizar la resprsentación del tiempo como cadena*

Ref          | Valor        
------------ | -------------
%a | Nombre del día de la semana abreviado
%A | Nombre del día de la semana completo
%b | Nombre del mes abreviado
%B | Nombre del mes completo
%c | preferred date and time representation
%C | Centuria (Año dividido por 100, 00 - 99)
%d | Día del mes (01 - 31)
%D | Lo mismo que %m/%d/%y
%e | Día del mes (1 - 31)
%g | Como %G, pero sin centuria
%G | Año en 4-digitos correspondiente al número de semana ISO (ver %V).
%h | Igual que %b
%H | Hora, formato 24h (00 - 23)
%I | Hora, formato 12h (01 - 12)
%j | Día del año (001 - 366)
%m | Mes (01 - 12)
%M | Minuto
%n | Salto de línea
%p | AM o PM en función de la hora
%r | Tiempo en formato a.m. y p.m.
%R | Tiempo en formato 24h
%S | Segundos
%t | Tabulación Horizontal
%T | Tiempo actual, igual que %H:%M:%S
%u | Día de la semana como numero (1 - 7), Lunes=1 o Domingo=1, en función del tipo de calendario
%U | Número de semana del año actual, empezando por el primer domingo del año como primera semana
%V | El número de semana del año actual según el ISO 8601 (01 - 53), la primera semana es la priemra semana que tenga cuatro días en el año actual, y el Lunes como primer día de la semana
%W | Número de semana del año actual, contando desde el primer lunes de la primera semana
%w | Día de la semana decimal, Domingo=0
%x | Represetnación de fecha preferida sin hora
%X | Represetnación de hora preferida sin fecha
%y | Año sin la centuria (00 - 99)
%Y | Año incluyendo la centuria
%Z | Zona Horaria o nombre o abreviación
%z | Igual que %Z 
%% | Caracter %

```python
import time
print (time.strftime("Semana %U - %b %d %Y %H:%M:%S", time.localtime())) # Semana 31 - Aug 05 2016 02:14:41
```

- .strptime(cadena_fecha [, formato]) *Retorna una fecha cuando introduccimos una cadena y descodificarla usando los formatos como strftime*
```python
import time
estructurado = time.strptime("Semana 31 - Aug 05 2016 02:14:41", "Semana %U - %b %d %Y %H:%M:%S")
print ("DateTuple:", estructurado)
# time.struct_time(tm_year=2016, tm_mon=8, tm_mday=5, tm_hour=2, tm_min=14, tm_sec=41, tm_wday=4, tm_yday=218, tm_isdst=-1)
```


### Python: Módulo calendar


**Importar el módulo**
```python
import calendar
```

**Métodos útiles**

- .month(year, month) *Creamos un calendario*
```python
import calendar
print(calendar.month(2017, 1)) 
#     January 2017
# Mo Tu We Th Fr Sa Su
#                    1
#  2  3  4  5  6  7  8
#  9 10 11 12 13 14 15
# 16 17 18 19 20 21 22
# 23 24 25 26 27 28 29
# 30 31
```

**Librerías interesantes**
- [Arrow](http://crsmithdev.com/arrow/)
- [fleming](https://github.com/ambitioninc/fleming)
- [World Timezone Definitions for Python](http://pytz.sourceforge.net/)
- [Moment](https://github.com/zachwill/moment)
- [mxDateTime](http://www.egenix.com/products/python/mxBase/mxDateTime/)
- [dateutil](https://github.com/dateutil/dateutil)
- [Delorean](https://github.com/myusuf3/delorean)


### Python: Hora y Fecha en la practica


**datetime el módulo clave**
```python
from datetime import datetime, date, time, timedelta
```

**Fecha y hora actual**

```python
from datetime import datetime
ahora = datetime.now()
print("Reloj:", ahora)               # Reloj: 2016-08-05 14:26:50.472811
print("Reloj (UTC):",ahora.utcnow()) # Reloj (UTC): 2016-08-05 14:26:50.474835

print("*******Detalles********")
print("Día:",ahora.day)              # Día: 5
print("Mes:",ahora.month)            # Mes: 8
print("Año:",ahora.year)             # Año: 2016
print("Hora:", ahora.hour)           # Hora: 14
print("Minutos:",ahora.minute)       # Minutos: 26
print("Segundos:", ahora.second)     # Segundos: 50
print("Ms:",ahora.microsecond)       # Ms: 472811
```

**Operar con fechas**
```python
from datetime import  date, timedelta

print("Ayer:", date.today() - timedelta(days=1))
print("Hoy:", date.today())
print("Mañana:", date.today() + timedelta(days=1))

tomorrow = date.today() + timedelta(days=1)
yesterday = date.today() - timedelta(days=1)
difference = tomorrow - yesterday

print("The difference is", difference) # The difference is 2 days, 0:00:00
print("La diferencia es de", difference.days, "días") # La diferencia es de 2 días
```

**Comparación de horas**
```python
from datetime import time

hora1 = time(12, 10, 25) 
hora2 = time(15, 9, 59) 

print("hora1 =", hora1) # 12:10:25
print("hora2 =", hora2) # 15:09:59
print("...es hora1 mayor que hora2?", hora1 < hora2)  # True
```

**Comparación de fechas**
```python
from datetime import date

fecha1 = date.today()
fecha2 = date.today() + timedelta(days=2)  

print("fecha1 =", fecha1) # 2016-08-05
print("fecha2 =", fecha2) # 2016-08-07
print("...es fecha1 mayor que fecha2?", fecha1 > fecha2)  # False
```


### Python: Cadenas
Tipos de cadenas y escapes
- Comillas simples
```python
simples = 'Esto son comillas \'simples\' y esto "dobles"'
```
- Comillas dobles
```python
dobles = "Esto son comillas \"dobles\" y esto 'simples'"
```
- Comillas triples
```python
triples = """Esto es \"\"\"triple\"\"\"... esto "doble"
y esto 'simple'. Además ...
guarda el formato!"""
```

- Alternativas a triple comilla
```python
alternativa_1 = "una línea...." + \
"otra línea..."
alternativa_2 = ("Una línea"
"Otra línea....")
```

### Python: Cadenas: Codificación

- Codificación UTF-8
```python
euro = "€" 
```
- Uso Unicode
```python
euro = "\u20AC"
euro = "\U000020AC"
```

### Python: Cadenas: Secuencias
- Es necesario manejar número enteros
- **Estructura**
```python
sec[inicio]
sec[inicio:fin]
sec[inicio:fin:paso]
``` 
- Ejemplos
```python
trozo = "Fictizia"[2] #c
trozo = "Fictizia"[-3] #z
trozo = "Fictizia"[-3:-1] #zi
trozo = "Fictizia"[1:-3] #icti
trozo = "Fictizia"[1:-3:2] #it
trozo = "Fictizia"[::2] #Fcii
trozo = "Fictizia"[::-2] #azti
``` 
- Paso a paso
``` 
 +---+---+---+---+---+---+---+---+
 | F | i | c | t | i | z | i | a |
 +---+---+---+---+---+---+---+---+
 0   1   2   3   4   5   6   7   
-8  -7  -6  -5  -4  -3  -2  -1
``` 

### Python: Cadenas: Métodos

- .capitalize() *Retorna la primera letra en mayúscula*
```python
"fictizia".capitalize() #Fictizia
```

- .center(longitud [, caracter]) *Retorna una cadena nueva con el texto original en el centro y los laterales rellenados*
```python
"fictizia".center(20) #      fictizia      
"fictizia".center(20, "-") #------fictizia------
```

- .count(cadenaBuscada [, empieza=0, termina=len(string)]) **
```python
"Fictizia".count("i") # 3
"Fictizia".count("zia") # 1
"Fictizia".count("i", 5, 7) # 1
```

- .encode(encoding, errores) *Retorna una versión codificada de la cadena original*
 - *errores* especifica el manejo del error. Recomendado *strict*	e *ignore*.[Manejo de errores en Python 3.x](https://docs.python.org/3/library/codecs.html#error-handlers)
 - *encoding* especifica la coficicación. [Lista de codigficaciones disponibles](https://docs.python.org/3/library/codecs.html#standard-encodings) 
```python
"Fictizia".encode('ascii','strict') # b'Fictizia'
```

- .decode(encoding, errores) *Retorna una versión decodificada de la cadena original*
 - *errores* especifica el manejo del error. Recomendado *strict*	e *ignore*.[Manejo de errores en Python 3.x](https://docs.python.org/3/library/codecs.html#error-handlers)
 - *encoding* especifica la coficicación. [Lista de codigficaciones disponibles](https://docs.python.org/3/library/codecs.html#standard-encodings) 
```python
b'Fictizia'.decode('utf-8','strict') # Fictizia
```

- .endswith(criterio [, empieza[, termina]]) *Retorna True si la cadena termina con cierto criterio. False si no coincide*
 - *Criterio* Determina lo que buscamos, puede ser una cadena de texto o una tupla.
 - *Empieza* opcional. Especifica el principio del tramo
 - *Termina* opcional. Especifica el fin del tramo
```python
"Fictizia".endswith("a") # True
"Fictizia".endswith("zi", 5 , 7) # True
"Fictizia".endswith(("zi", "a")) # True
"Fictizia".endswith(("zi", "a"), 5 , 7) # True
```

- .expandtabs(size) *Retorna una versión de la cadena donde los \t se convierten en espacios definidos por nosotros*
```python
(6*"Fictizia\t").expandtabs(4) # Fictizia    Fictizia    Fictizia...   
```

- .find(criterio [, inicio[, fin]]) *Retorna la posición del criterio o -1 si no lo encuentra*
```python
"Fictizia".find("zi") # 5
"Fictizia".find("yo") # -1
```

- .index(criterio [, inicio[, fin]]) *Similar a find(), pero si no encuentra lanza un error*
```python
"Fictizia".index("zi") # 5
"Fictizia".index("yo") # ValueError: substring not found
```

- .isalnum() *Verifica si es alfanumerico*
```python
"Fictizia".isalnum() # True
"#Fictizia".isalnum() # False
```

- .isalpha() *Verifica si es un carácter alfanumerico*
```python
"Fictizia".isalpha() # True
"123".isalpha() # False
```

- .isdigit() *Verifica si es un dígito alfanumerico*
```python
"Fictizia".isdigit() # False
"123".isdigit() # True
```

- .islower() *Verifica si esta en minúsculas*
```python
"Fictizia".islower() # False
"fictizia".islower() # True
```

- .isupper() *Verifica si esta en Mayúsculas*
```python
"Fictizia".isupper() # False
"FICTIZIA".isupper() # True
```

- .isnumeric() *Verifica si es un dígito alfanumerico*
```python
"Fictizia".isnumeric() # False
"123".isnumeric() # True
```

- .isspace() *Verifica una cadena consiste unicamente de espacios en blanco*
```python
"Fictizia".isspace() # False
"Fictizia   Fictizia".isspace() # False
"     ".isspace() # True
```

- .istitle() *Verifica si cada una de las palabras que componene la cadena empeiza por mayuscula y el resto no*
```python
"Fictizia Fictizia".istitle() # True
"Fictizia fictizia".istitle() # False
"Fictizia FICTIZIA".istitle() # False
```

- .isdecimal() *Verifica si una cadena consiste unicamente de decimales.*
```python
"00215487521".isdecimal() # True
"123456789".isdecimal() # True
"1a123".isdecimal() # False
```

- .join(secuencia) *Retorna una cadena que concatena los elementos de una tupla o lista con un criterio*
```python
"-".join(("aaa", "b", "CCCC")) # aaa-b-CCCC
"*".join(["A", "Z", "D"]) # A*Z*D
```

- len(cadena) *Retorna la longitud de una cadena*
```python
len("Fictizia") # 8
```

- .ljust(longitud[, relleno]) *Retorna una cadena justificada a la izquierda, criterio de relleno opcional*
```python
"Fictizia".ljust(12) # 'Fictizia    '
"Fictizia".ljust(15, '*') # Fictizia*******
```

- .rjust(longitud[, relleno]) *Retorna una cadena justificada a la derecha, criterio de relleno opcional*
```python
"Fictizia".rjust(12) # '    Fictizia'
"Fictizia".rjust(15, '*') # *******Fictizia
```


- .lower() *Retorna una cadena con todas las letras en minúsculas*
```python
"Fictizia".lower() # fictizia
```

- .upper() *Retorna una cadena con todas las letras en mayúsculas*
```python
"fictizia".upper() # FICTIZIA
```

- .lstrip([caracter]) *Retorna una cadena con los espacios en blanco de la izquierda eliminados, u otro caracter*
```python
"      Fictizia".lstrip() # Fictizia
"===Fictizia===".lstrip() # ===Fictizia===
"===Fictizia===".lstrip("=") # Fictizia===
```

- .strip([caracter]) *Retorna una cadena con los espacios en blanco eliminados, u otro caracter*
```python
"      Fictizia    ".strip() # Fictizia
"===Fictizia===".strip() # ===Fictizia===
"===Fictizia===".strip("=") # Fictizia
```

- .rstrip([caracter]) *Retorna una cadena con los espacios en blanco de la derecha eliminados, u otro caracter*
```python
"Fictizia      ".rstrip() # Fictizia
"===Fictizia===".rstrip() # ===Fictizia===
"===Fictizia===".rstrip("=") # ===Fictizia
```

- .maketrans(originales, nuevos) y translate() *sustituye unos caracteres por otros. Retorna una cadena con los valores sustituidos*
```python
original = "Fictizia"
cambio = original.maketrans("ia", "1@") #{105: 49, 97: 64}
modificado = original.translate(cambio) # F1ct1z1a
print(original+" es "+modificado) # Fictizia es F1ct1z1@
```

- max() *Retorna el caracter alfabetico más alto en una cadena*
```python
max("Fictizia") # z
```

- min() *Retorna el caracter alfabetico más bajo en una cadena*
```python
min("Fictizia") # F
min("FictiziA") # A
min("fictizia") # a
min("fictizia.") # .
```

- .replace(viejo, nuevo [, maximo]) *Retorna una cadena con el remplazo *
```python
"Fictizia".replace("ia", "IA") # FictizIA
```

- .rfind(secuencia, [, inicio[, fin]]) *Retorna la posición de la última coincidencia o -1*
```python
"Fictizia".rfind("i") # 6
"Fictizia".rfind("q") # -1
```

- .rindex(secuencia, [, inicio[, fin]]) *Igual que frind() peor retorna un error en caso negativo*
```python
"Fictizia".rindex("i") # 6
"Fictizia".rindex("q") # ValueError: substring not found
```

- .split(criterio, [, maximo]) *Retorna una lista con los trozos divididos por el criterio*
```python
"Fictizia".split("i") # ['F', 'ct', 'z', 'a']
"Fictizia Fictizia".split() # ['Fictizia', 'Fictizia']
```

- .splitlines() *Retorna una lista con las líneas*
```python
"Una línea\n otra\n más míneas...".splitlines() # ['Una línea', ' otra', ' más míneas...']
```

- .startswith(secuencia, [, inicio[, fin]) *Verifica si un texto empieza por...*
```python
"Fictizia".startswith("F") # True
"Fictizia".startswith("i") # False
```

- .swapcase() *Retorna una cadena con las mayúsculas y minúsculas invertidas*
```python
"Fictizia".swapcase() # fICTIZIA
```

- .title() *Retorna una cadena con las primera letra de cada palabra en mayúsculas, el resto en minúsculas*
```python
"fICTIZIA".title() #Fictizia
```

- .zfill(tope) *Rellena con ceros a la izquierda hasta un tope (incluyendo el largo de la cadena original)*
```python
"Fictizia".zfill(10) # 00Fictizia (8+2)
```

### Python: Listas

- Creando una lista:
```python
listaVacia = []
lista = [1, "platano", "piscina", "manzana", True]
```

- Usando el Índice:
```python
lista = [1, "platano", "piscina", "manzana", True]
print("lista[0]: ", lista[0]) # 1
print("lista[1:2]: ", lista[1:2]) # ['platano']
print("lista[2:4]: ", lista[2:4]) # ['piscina', 'manzana']
```

- Cambiar un valor del Índice:
```python
lista[0] = "fresa"
lista[4] = "pera"
lista[2] = "limón"
print("lista[0:4]: ", lista[0:4]) # ['fresa', 'platano', 'limón', 'manzana']
```

- Borrando elementos
```python
print("lista: ", lista) # ['fresa', 'platano', 'limón', 'manzana', 'pera']
del lista[0]
del lista[3]
print("lista: ", lista) # ['platano', 'limón', 'manzana']
```

**Operaciones Básicas**
- Longitud
```python
len(lista) # 3
```

- Concatenación
```python
lista1 = [1, "platano"]
lista2 = ["piscina", "manzana", True]
lista = lista1 + lista2 # [1, 'platano', 'piscina', 'manzana', True]
```

- Repetición
```python
lista1 = [1, "platano"]
lista = lista1 * 5 # [1, 'platano', 1, 'platano', 1, 'platano', 1, 'platano', 1, 'platano']
```

- Pertenencía
```python
lista2 = ["piscina", "manzana", True]
print("Tenemos piscina?: ", "piscina" in lista2) # True
print("Tenemos agua?: ", "agua" in lista2) # False
```

- Iteración
```python
lista = ["piscina", "manzana", True]
for i in lista : 
    print("Elemento de la lista:", i)
```


**Propiedades**

- max(lista) *Retorna el mayor elemento de la lista*
```python
lista = [123, 234, 345, 456, 1, 500, 503, 1000]
max(lista) # 1000
```

- min(lista) *Retorna el menor elemento de la lista*
```python
lista = [123, 234, 345, 456, 1, -500, 503, 1000]
min(lista) # -500
```

- tuple(lista) *Convierte una lista en tupla*
```python
datos = [123, 234, 1000]
print("datos es...?", type(datos)) # <class 'list'>
datos = tuple(datos)
print("datos es...?", type(datos)) # <class 'tuple'>
```


**Métodos**

- .count(elemento) *Cuantas veces se repite un elemento en la lista*
```python
lista = [123, 234, -5, 345, 456, 1, -5, 503, 1000]
lista.count("Platano") # 0
lista.count(-5) # 2
```

- .extend(elemento) *Extiende cierto contenido a una lista*:
```python
lista = [1, 2, 3]
lista.extend([4, 5])
print ("Lista:", lista) # Lista: [1, 2, 3, 4, 5]
```

- .index(elemento) *Retorna la posición o un error de un elemento*:
```python
lista = [1, 2, 3]
print ("donde esta 2?:", lista.index(2)) # 1
print ("donde esta \"platano\"?:", lista.index("platano")) # ValueError: 'platano' is not in list
```

- .append(elemento) *Añadir elemento al índice (Final)*:
```python
lista.append("nuevo");
```

- .insert(posicion, elemento) *Añadir un elemento en una posición concreta*:
```python
lista = [1, 2, 3]
lista.insert(1, "nuevo") # [1, 'nuevo', 2, 3]
```

- .pop([posicion]) *Eliminar el último o un elemento de la lista y lo retorna*:
```python
lista = [1, 2, 3, "platano", "piscina", True]
lista.pop() # True
platanito = lista.pop(3) # platano
```

- .remove(elemento) *Eliminar un elemento de la lista*:
```python
lista = [1, 2, 3, "platano", "piscina", True]
lista.remove("platano") # [1, 2, 3, 'piscina', True]
lista.remove(5) # ValueError: list.remove(x): x not in list
```

- .reverse() *Altera el orden de una lista*:
```python
lista = [1, 2, 3, "platano", "piscina", True]
lista.reverse() # [True, 'piscina', 'platano', 3, 2, 1]
```

- .sort([func]) *Ordenar la lista*:
```python
frutas = ['Platano', 'Naranja', 'Limón', 'Manzana', 'Mango']
frutas.sort() # ["Limón", "Mango", "Manzana", "Naranja", "Platano"]
	
lista = ['uno', 2, True, 'más datos...']
lista.sort() # TypeError: unorderable types: int() < str()
```

### Python: Matrices
- Listas anidadas
```python
matriz = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print(matriz[1]) # [4, 5, 6]
print(matriz[1][2]) # 6
```

### Python: Tuplas
Importante: Las tuplas son listas inmutables

- Creando una lista:
```python
tuplaVacia = ()
tupla = (1, "platano", "piscina", "manzana", True)
```

- Usando el Índice:
```python
tupla = (1, "platano", "piscina", "manzana", True)
print("tupla[0]: ", tupla[0]) # 1
print("tupla[1:2]: ", tupla[1:2]) # ['platano']
print("tupla[2:4]: ", tupla[2:4]) # ['piscina', 'manzana']
```

- Actualizar una tupla:
```python
tupla = (1, "platano", "piscina", "manzana", True)
tupla = ('fresa', 'platano', 'limón', 'manzana', 'pera')
```

- Borrando una tupla
```python
tupla = ('fresa', 'platano', 'limón', 'manzana', 'pera')
del tupla
print("tupla?", tupla) # NameError: name 'tupla' is not defined
```

**Operaciones Básicas**
- Longitud
```python
tupla = ('fresa', 'platano', 'limón', 'manzana', 'pera')
len(tupla) # 5
```

- Concatenación
```python
tupla1 = (1, "platano")
tupla2 = ("piscina", "manzana", True)
tupla = tupla1 + tupla2 # (1, 'platano', 'piscina', 'manzana', True)
```

- Repetición
```python
tupla1 = (1, "platano")
tupla = tupla1 * 5 # (1, 'platano', 1, 'platano', 1, 'platano', 1, 'platano', 1, 'platano')
```

- Pertenencía
```python
tupla = ("piscina", "manzana", True)
print("Tenemos piscina?: ", "piscina" in tupla) # True
print("Tenemos agua?: ", "agua" in tupla) # False
```

- Iteración
```python
tupla = ("piscina", "manzana", True)
for i in tupla : 
    print("Elemento de la tupla:", i)
```


**Propiedades**

- max(lista) *Retorna el mayor elemento de la lista*
```python
lista = [123, 234, 345, 456, 1, 500, 503, 1000]
max(lista) # 1000
```

- min(lista) *Retorna el menor elemento de la lista*
```python
lista = [123, 234, 345, 456, 1, -500, 503, 1000]
min(lista) # -500
```

- list(tupla) *Convierte una tupla en lista*
```python
datos = (123, 234, 1000)
print("datos es...?", type(datos)) # <class 'tuple'>
datos = list(datos)
print("datos es...?", type(datos)) # <class 'list'>
```


### Python: Sets
- Es una colación de datos desordenada
- No permite datos duplicados
- Se pueden utilizar para eliminar elementos repetidos en otra colección de datos
```python
vacio = set() #
cadena = set("Fictizia") # {'a', 'F', 'z', 'i', 't', 'c'}
lista = set([2,2,2,21,1,3,4,5]) # {1, 2, 3, 4, 5, 21}
```
- Se pueden utilizar el mismo principio con varios sets 
```python
set1 = set("Fictizia")
set2 = set("Python y Django")

print("Elementos únicos en 'set1':", set1) # Elementos únicos en 'set1': {'a', 'F', 'z', 'i', 't', 'c'}
print("Elementos únicos en 'set2':", set2) # Elementos únicos en 'set2': {'P', ' ', 'j', 'a', 'g', 'n', 'h', 'o', 'y', 't', 'D'}

print("Elementos en set1 pero no en set2", set1 - set2 ) # {'i', 'F', 'z', 'c'}
print("Elementos en set2 pero no en set1", set2 - set1 ) # {'P', ' ', 'j', 'g', 'n', 'h', 'o', 'y', 'D'}

print("Elementos que no repetidos en set1 y set2", set1 | set2 ) #  {'P', 'h', 'o', 'F', 'z', 'i', 'D', 'g', ' ', 'j', 'a', 'n', 'y', 't', 'c'}

print("Elementos en común entre set1 y set2", set1 & set2 ) #  Elementos en común entre set1 y set2 {'t', 'a'}

print("Elementos que no se repitan entre set1 y set2", set1 ^ set2 ) # Elementos que no se repitan entre set1 y set2 {'P', ' ', 'j', 'g', 'n', 'h', 'o', 'F', 'z', 'i', 'y', 'D', 'c'}
```

### Python: Diccionarios

- Creando un diccionario:
```python
dic = {
    "cadena": "esto es una cadena",
	"numero": 2,
	"booleano": False
}
```

- Accediendo a los datos:
```python
dic = {'booleano': False, 'numero': 2, 'cadena': 'esto es una cadena'}
print("dic[\"booleano\"]: ", dic["booleano"]) # False
print("dic[\"cadena\"]: ", dic["cadena"]) # esto es una cadena
print("dic[\"inventado\"]: ", dic["inventado"]) # KeyError: 'inventado'
```

- Actualizar un diccionario:
```python
dic = {'booleano': False, 'numero': 2, 'cadena': 'esto es una cadena'}
dic["booleano"] = True
dic["lista"] = [1,2,3,4,5,True,"cadena"]
print(dic) # {'booleano': True, 'numero': 2, 'cadena': 'esto es una cadena', 'lista': [1, 2, 3, 4, 5, True, 'cadena']}
```

- Borrando en un diccionario
```python
dic = {'booleano': False, 'numero': 2, 'cadena': 'esto es una cadena'}

del dic['booleano']     # Borrar una propiedad
print("dic: ", dic)     # dic:  {'numero': 2, 'cadena': 'esto es una cadena'}

dic.clear()             # Vaciar el diccionario
print("dic: ", dic)     # dic:  {}

del dic                 # Eliminar el diccionario
print("dic: ", dic)     # NameError: name 'dic' is not defined
```

**Propiedades**

- string(dic) *Retorna una cadena con todos los elementos del diccionario*
```python
dic = {'booleano': False, 'numero': 2, 'cadena': 'esto es una cadena'}
print ("Cadena equivalente:", str(dic)) # Cadena equivalente: {'booleano': False, 'numero': 2, 'cadena': 'esto es una cadena'}
```

- len(dic) *Retorna la longitud del diccionario*
```python
dic = {'booleano': False, 'numero': 2, 'cadena': 'esto es una cadena'}
print ("Longitud:", len(dic)) # Longitud: 3
```

**Métodos**

- .copy() *Retorna una copia (shadow copy)*
    - Shadow copy copia los objetos de primer nivel, pero los anidados sólo por referencia    
```python
dic = {'booleano': False, 'numero': 2, 'cadena': 'esto es una cadena'}

dicShadow = dic.copy()
```

- .fromkeys(secuencia [, valor]) *Permite crear un diccionario partiendo de una tupla y valores por defecto*
```python
secuencia = ("dato", "dato2", "otroDato", "mas datos")

dic = dic.fromkeys(secuencia) 
# {'otroDato': None, 'dato': None, 'mas datos': None, 'dato2': None}

otroDic = dic.fromkeys(secuencia, "dato por defecto")
# {'otroDato': 'dato por defecto', 'dato': 'dato por defecto', 'mas datos': 'dato por defecto', 'dato2': 'dato por defecto'}
```

- .get(llave [, retorno_negativo]) *Devuelve el valor de una llave, si no estuviera retorna None o el valor que nosostros definamos*
```python
dic = {'booleano': False, 'numero': 2, 'cadena': 'esto es una cadena'}
print("Cadena:", dic.get("cadena")) # Cadena: esto es una cadena
print("Inventada:", dic.get("Inventada")) # Inventada: None
print("Inventada:", dic.get("Inventada", False)) # Inventada: False
```

- .setdefault(llave [, valor_defecto]) *Ajusta un valor por defecto en caso que no exista*
```python
dic = {'booleano': False, 'numero': 2, 'cadena': 'esto es una cadena'}
dict.setdefault('cadena', "Otra...")
dict.setdefault('otraCadena', False)
print("dic:", dic) # dic: {'booleano': False, 'numero': 2, 'cadena': 'esto es una cadena'}
```

- .items() *Retorna una lista con todos los elementos de un diccionario.*
```python
dic = {'booleano': False, 'numero': 2, 'cadena': 'esto es una cadena'}
dic.items() # dict_items([('booleano', False), ('numero', 2), ('cadena', 'esto es una cadena')])
```

- .keys() *Retorna una lista con todas las llaves de un diccionario.*
```python
dic = {'booleano': False, 'numero': 2, 'cadena': 'esto es una cadena'}
dic.keys() # dict_keys(['booleano', 'numero', 'cadena'])
```

- .values() *Retorna una lista con todos los valores de un diccionario.*
```python
dic = {'booleano': False, 'numero': 2, 'cadena': 'esto es una cadena'}
dic.values() # dict_values([False, 2, 'esto es una cadena'])
```

- .update(dic2) *Añade el contenido de un diccionario en otro*
```python
dic = {'booleano': False}
dic1 = {'numero': 2, 'cadena': 'esto es una cadena'}
dic.update(dic1) # {'booleano': False, 'numero': 2, 'cadena': 'esto es una cadena'}
```

